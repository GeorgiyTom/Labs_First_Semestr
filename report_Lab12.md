# Отчет по лабораторной работе N 12 по курсу
# "Фундаментальная информатика"

Студент группы: M8O-104Б-21, Томаев Георгий Альбердович\
Контакты: georgiitomaev132@gmail.com\
Работа выполнена: 25.10.2021\
Преподаватель: Безлуцкая Елизавета Николаевна

## 1. Тема

Язык программирования C.

## 2. Цель работы

Разработка алгоритма на языке программирования C.

## 3. Задание

Выбрать идущие подряд тройки цифр, упорядоченных по возрастанию.

## 4. Оборудование

Процессор: Intel(R) Pentium(R) CPU 4417U @ 2.30GHz 2.30 GHz\
ОП: 3973 Мб\
НМД: 1024 Гб\
Монитор: 1920x1080

## 5. Программное обеспечение

Microsoft Visual Studio Code (User)\
v 1.61.2

## 6. Идея, метод, алгоритм решения задачи

Идея состоит в том, чтобы "отсекать" от текущего числа последние 3 цифры и проверять, идут ли они по возрастанию и, соответсвенно, выводить тройку, если идут и игнорировать в противном случае. Важно, что мы рассматриваем все возможные тройки.

## 7. Сценарий выполнения работы

Пусть задано число 1234567. Результатом работы алгоритма должна быть последовательность 567 456 345 234 123. Первое, что приходит в голову, это использовать остаток от деления на 1000, чтобы отделить последние 3 цифры. То есть 1234567 % 1000 = 567. Далее идет проверка на возрастание чисел от старшего разряда к младшему. Тут все также нам на помощь приходит остаток от деления, но теперь уже на 10. Таким образом мы "разбиваем" тройку на 3 числа a = 5, b = 6, c = 7, и проверяем условие: a < b < c. Выводим тройку, если True и игнорируем при False. В конце важно не забыть "обрубить хвост", то есть последнюю цифру. Делается это при помощи целочисленного деления на 10.

## 8. Распечатка протокола
```
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int mod(int a_new, int b_new)
{
    a_new = abs(a_new);
    b_new = abs(b_new);
    if ((a_new < b_new)) {
        return a_new;
    } else if (a_new > b_new) {
        a_new = a_new - (a_new / b_new) * b_new;
        return a_new;
    } else {
        return 0;
    }
}
int main(void)
{
    long int input;
    int triple, temp, discharge_1, discharge_2, discharge_3;
    while (scanf("%ld", &input) != EOF) {
        if (input != EOF) {
            if (input == INT_MIN) {
                printf("%d", 147);
            } else if (input == INT_MAX) {
                printf("%d", 147);
            } else {
                input = abs(input);
                while (input > 99) {
                    triple = mod(input, 1000);
                    temp = triple;
                    discharge_1 = mod(temp, 10);
                    temp /= 10;
                    discharge_2 = mod(temp, 10);
                    temp /= 10;
                    discharge_3 = mod(temp, 10);
                    if (discharge_3 < discharge_2 && discharge_2 < discharge_1 && discharge_3 == 0) {
                        printf("%d", 0);
                        printf("%d ", triple);
                    } else if (discharge_3 < discharge_2 && discharge_2 < discharge_1) {
                        printf("%d ", triple);
                    }
                    input /= 10;
                }
            }
        } else {
            break;
        }
        printf("\n");
    }
    printf("\n");
    return 0;
}
```

## 9. Дневник отладки

| № | Лаб. или дом. | Дата       | Время     | Событие                  | Действие по исправлению | Примечание  |
|---|---------------|------------|-----------|--------------------------|-------------------------|-------------|
| 1 | Лаб.          | 15.11.2021 | 16:22     | Провал на 34 тесте       | Не учел случай с ведущим нулем в тройке, исправил этот недочет             |  |
| 2 | Лаб.          | 15.11.2021 | 16:35     | Провал на 66 тесте       | Не учел случай с границами INT_MIN - INT_MAX |                                    | Добавил условие для предотвращения переполнения памяти |

## 10. Замечания автора по существу работы

В качестве примера в чекере приведены некорректные выходные данные, в связи с чем я пришел в замешательство и потратил на выполнение данной лабораторной работы больше времени.

## 11. Выводы

За время написания работы научился писать несколько интересных функций, а также изучил особенности чекера. Также освоил пределы типов данных и ознакомился с ошибкой stackoverflow.

