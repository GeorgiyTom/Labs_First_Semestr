# Отчет по лабораторной работе N 14 по курсу
# "Фундаментальная информатика"

Студент группы: M8O-104Б-21, Томаев Георгий Альбердович\
Контакты: georgiitomaev132@gmail.com\
Работа выполнена: 25.10.2021\
Преподаватель: Безлуцкая Елизавета Николаевна

## 1. Тема

Разработка программы в языке программирования C.

## 2. Цель работы

Приобретение навыков написания алгоритмов и их реализации на языке программирования C.

## 3. Задание

На вход подаётся пакет тестов, содержащий набор квадратных матриц. Необходимо вывести элементы матрицы "спиралью" через пробел.

![image](https://user-images.githubusercontent.com/90094333/145954712-887cc22c-b8a6-4b3c-84eb-cf372f2babdd.png)


## 4. Оборудование

Процессор: Intel(R) Pentium(R) CPU 4417U @ 2.30GHz 2.30 GHz\
ОП: 3973 Мб\
НМД: 1024 Гб\
Монитор: 1920x1080

## 5. Программное обеспечение

Microsoft Visual Studio Code (User)\
v 1.61.2

## 6. Идея, метод, алгоритм решения задачи
Одна из первых идей, приходящих в голову - создать параметры движения. Для каждого направления нужно придумать свою переменную. По факту у нас всего 2 переменные: вниз и вправо, в то время как аналоги вверх и влево являются противоположными данным, но необходимыми в программе. Начинаем движение всегда с центра матрицы, причем у матриц, с четным порядком он будет определяться как ```n / 2 - 1```, в то время как у нечетных ```n / 2``` и это также тонкий момент программы. Третьим примечанием является то, что после того, как мы прошли вверх по строкам матрицы, нужно присвоить переменной down(вниз) значение переменной up(вверх), так как именно с этой строки мы будем насинать свое движение вниз. Аналогично поступаем с переменной right(вправо) относительно переменной left(влево). Это основные принципы реализации данного задания.
P.S. переменные down и up отвечают за перемещение по строкам, а переменные right и left - по столбцам.

## 7. Сценарий выполнения работы

Отдельное внимание стоит уделить условию завершения программы. То есть момент, когда считан последний элемент матрицы для вывода. Если это не продумать, то, очевидно, будет совершаться выход за границы массива. Нетрудно заметить, что у матриц с нечетным порядком (1, 3, 5...) последним элементом будет An0, а у четных - A0n. Интерпритация в программе:
```
if (mas[down][left] == mas[test - 1][0] && test % 2 != 0) {
   temp = 0;
   break;
}
```
Этот кусок кода используется внутри повышения параметра движения down т к именно он, в конечном счете отвечает за то самое n. Мы проверяем выполняется ли условие: элемент == An0(для нечетного). Если да, то переменная temp обнуляется, отвечающая за основной цикл while, который работает пока temp == 1. Соответсвенно, при temp == 0 мы выдетаем из цикла и переходим к следующему тесту.
P.S.S задавать значения переменным нужно внутри основного for-а, т к иначе будут возникать ошибки.

## 8. Распечатка протокола

```
#include <stdio.h>

int main(void)
{
    int ans, temp = 1, count, max_size, i, m, j, test, q, a, centre, down, down_2, right, right_2, left_2, up_2, left, up, centre_2;
    scanf("%d%d", &count, &max_size);
    int mas[max_size][max_size];
    for (m = 0; m < count; m++) {
        scanf("%d", &test);
        if (test == 1) {
            scanf("%d", &ans);
            printf("%d\n", ans);

        } else if (test == 0) {
            continue;
        } else {
            for (q = 0; q < test; q++) {
                for (a = 0; a < test; a++) {
                    scanf("%d", &mas[q][a]);
                }
            }
            if (test % 2 == 0) {
                centre = test / 2 - 1;
            } else {
                centre = test / 2;
            }
            down_2 = right_2 = centre + 1;
            left_2 = up_2 = centre - 1;
            down = left = right = up = centre;
            temp = 1;
            printf("%d ", mas[centre][centre]);
            while (temp == 1) {
                while (down < down_2) {
                    down += 1;
                    printf("%d ", mas[down][left]);
                    if (mas[down][left] == mas[test - 1][0] && test % 2 != 0) {
                        temp = 0;
                        break;
                    }
                }
                if (temp == 0) {
                    break;
                }
                if (down_2 < test) {
                    down_2 += 1;
                }
                while (right < right_2) {
                    right += 1;
                    printf("%d ", mas[down][right]);
                }
                if (right_2 < test) {
                    right_2 += 1;
                }
                up = down;
                while (up > up_2) {
                    up -= 1;
                    printf("%d ", mas[up][right]);
                    if (mas[up][right] == mas[0][test - 1] && (test % 2 == 0)) {
                        temp = 0;
                        break;
                    }
                }
                if (temp == 0) {
                    break;
                }
                if (up_2 > 0) {
                    up_2 -= 1;
                }
                left = right;
                while (left > left_2) {
                    left -= 1;
                    printf("%d ", mas[up][left]);
                }
                if (left_2 > 0) {
                    left_2 -= 1;
                }
                down = up;
                right = left;
            }
            printf("\n");
        }
    }
    return 0;
}

```

## 9. Дневник отладки

| № | Лаб. или дом. | Дата       | Время     | Событие                  | Действие по исправлению | Примечание  |
|---|---------------|------------|-----------|--------------------------|-------------------------|-------------|
| 1 | Лаб.          | 14.12.2021 | 18:32     | ошибка на 6 тесте        | Начал обнулять temp в начале ввода новой матрицы. | |
| 2 | Лаб.          | 14.12.2021 | 23:51     | ошибка на 8 тесте        | Для матриц при n = 0 ничего не вывожу. | |

## 10. Замечания автора по существу работы

В чекере нет примечаний, что выводить при кол-ве тестов = 0 и порядке матриц = 0. Приходится додумывать самому, что отнимает некоторое время.

## 11. Выводы

Данная лабораторная работа хорошо развивает умение тестировать программу в голове (так как очень сложно засылать вручную огромные тесты), что в свою очередь хорошо развивает алгоритмическое мышление. Также работа повышает навыки работы с двумерными массивами.

