# Отчет по лабораторной работе N 11 по курсу
# "Фундаментальная информатика"

Студент группы: M8O-104Б-21, Томаев Георгий Альбердович\
Контакты: georgiitomaev132@gmail.com\
Работа выполнена: 25.10.2021\
Преподаватель: Безлуцкая Елизавета Николаевна
## 1. Тема

Язык программирования C.

## 2. Цель работы

Разработка алгоритма на языке программирования C.

## 3. Задание

Требуется подсчитать количество положительных десятичных чисел в строке, допустимых 16-битными процессорами.

## 4. Оборудование

Процессор: Intel(R) Pentium(R) CPU 4417U @ 2.30GHz 2.30 GHz\
ОП: 3973 Мб\
НМД: 1024 Гб\
Монитор: 1920x1080

## 5. Программное обеспечение

Microsoft Visual Studio Code (User)\
v 1.61.2

## 6. Идея, метод, алгоритм решения задачи

Первым делом нужно понять, как будет осуществляться отбор чисел от других символов. Естественно, для этого нужна функция на проверку, является ли очередной символ числом? Если да, то возвращаем 1, если нет - 0. Итак, у нас есть  функция проверки символа на число. Далее все просто: если символ число, то мы "добавляем" его как разряд к уже построенному(или еще нет) числу на предыдущих шагах. Иначе сбрасываем построенное число и плюсуем ответ, если он соответсвует условиям задачи. Но так как это действие нужно производить с разными строками, то также необходим цикл while, который будет работать, пока очередной символ не равен '\n'. Иначе выводим накопленный ответ и сбрасываем все значения к начальным.
![image](https://user-images.githubusercontent.com/90094333/144013978-3c14174a-d413-4b61-9710-5b7a913bded9.png)


## 7. Сценарий выполнения работы

На строке "11 lab is es":\
Пусть есть переменная f = getchar()\
Тогда f1 = '1'\
Есть какая-то функция is_numb(char a), которая возвращает 1, если символ - цифра.\
=> is_numb(f1) вернет 1\
Далее мы проверяем условие, что f1 не равно '\n' и заходим в цикл.\
Проверяем условие, что is_numb(f1) == 1. Оно верно, значит увеличиваем счетчик на 1 и считываем следующий символ. Это продолжается до тех пор, пока мы не встретим пробел, либо\ таб. Тогда is_numb(f1) == 0 и, очевидно, мы заходим в else if, где проверяем условие приплюсовывания к ответу единицы(счетчика чисел) и обнуляем переменную count, читая следующий символ. Дойдя до f1 == '\n', выводим ответ и читаем новый символ, обнуляя счетчик ответа. 

## 8. Распечатка протокола

```
#include <stdio.h>
#include <math.h>
#define UDI_MAX 65536

int ch_to_int(char a)
{
    if (a == '0') {
        return 0;
    } else if (a == '1') {
        return 1;
    } else if (a == '2') {
        return 2;
    } else if (a == '3') {
        return 3;
    } else if (a == '4') {
        return 4;
    } else if (a == '5') {
        return 5;
    } else if (a == '6') {
        return 6;
    } else if (a == '7') {
        return 7;
    } else if (a == '8') {
        return 8;
    } else if (a == '9') {
        return 9;
    } else {
        return -1;
    }
}
int is_numb(char a)
{
    if (a == '0') {
        return 1;
    } else if (a == '1') {
        return 1;
    } else if (a == '2') {
        return 1;
    } else if (a == '3') {
        return 1;
    } else if (a == '4') {
        return 1;
    } else if (a == '5') {
        return 1;
    } else if (a == '6') {
        return 1;
    } else if (a == '7') {
        return 1;
    } else if (a == '8') {
        return 1;
    } else if (a == '9') {
        return 1;
    } else {
        return 0;
    }
}
int quarter(int a, int b)
{
    if (b == 0) {
        return 1;
    } else {
        while (b != 1) {
            a *= b;
            b -= 1;
        }
        return a;
    }
}

int main(void)
{
    char f;
    int count = 0, d_1 = 0, d_2 = 0, d_3 = 0, d_4 = 0, d_5 = 0, sum = 0, ans = 0, flag = 1, priznak = 0;
    f = getchar();
    while (f != EOF) {
        while (f != '\n' && f != EOF) {
            if (f != '-') {
                if (is_numb(f) == 1 && priznak == 0) {
                    count += 1;
                    flag = 1;
                    if (count == 1 && (ch_to_int(f) != 0)) {
                        d_1 = ch_to_int(f);
                    } else if (ch_to_int(f) == 0) {
                        count -= 1;
                    }
                    if (count > 1 && count < 6) {
                        d_1 *= 10;
                    }
                    if (count == 2) {
                        d_2 = ch_to_int(f);
                    }
                    if (count > 2 && count < 6) {
                        d_2 *= 10;
                    }
                    if (count == 3) {
                        d_3 = ch_to_int(f);
                    }
                    if (count > 3 && count < 6) {
                        d_3 *= 10;
                    }
                    if (count == 4) {
                        d_4 = ch_to_int(f);
                    }
                    if (count > 4 && count < 6) {
                        d_4 *= 10;
                    }
                    if (count == 5) {
                        d_5 = ch_to_int(f);
                    }
                    f = getchar();
                } else if ((f == ' ') || (f == '\t')) {
                    sum = d_1 + d_2 + d_3 + d_4 + d_5;
                    if ((sum <= UDI_MAX) && (sum > 0) && (flag == 1) && count > 0 && count < 6) {
                        ans += 1;
                        flag = 0;
                    }
                    d_1 = d_2 = d_3 = d_4 = d_5 = 0;
                    count = 0;
                    f = getchar();
                    priznak = 0;
                } else if (f == '+' && priznak == 0) {
                    sum = d_1 + d_2 + d_3 + d_4 + d_5;
                    if ((sum <= UDI_MAX) && (sum > 0) && (flag == 1) && count > 0 && count < 6) {
                        ans += 1;
                        flag = 0;
                    }
                    d_1 = d_2 = d_3 = d_4 = d_5 = 0;
                    count = 0;
                    f = getchar();
                    priznak = 0;
                } else {
                    d_1 = d_2 = d_3 = d_4 = d_5 = 0;
                    count = 0;
                    f = getchar();
                    priznak = 1;
                }
            } else if (f == '-') {
                while (f != ' ' && f != '\n' && f != '\t') {
                    f = getchar();
                }
            }
        }
        if (count > 0 && count < 6 && f == '\n' && ((d_1 + d_2 + d_3 + d_4 + d_5) <= UDI_MAX) && ((d_1 + d_2 + d_3 + d_4 + d_5) > 0)) {
            ans += 1;
            count = 0;
            priznak = 1;
            d_1 = d_2 = d_3 = d_4 = d_5 = 0;
            flag = 1;
        } else {
            count = 0;
            priznak = 1;
            d_1 = d_2 = d_3 = d_4 = d_5 = 0;
            flag = 1;
        }
        printf("%d\n", ans);
        ans = 0;
        f = getchar();
    }
    
    return 0;
}
```

## 9. Дневник отладки

| № | Лаб. или дом. | Дата       | Время     | Событие                  | Действие по исправлению | Примечание  |
|---|---------------|------------|-----------|--------------------------|-------------------------|-------------|
| 1 | Лаб.          | 19.11.2021 | 20:04     | ошибка на 4 тесте        | Добавил условие для исключения зацикливания | |

## 10. Замечания автора по существу работы

Замечаний нет.

## 11. Выводы

На мой взгляд это одна из лучших лабораторных работ, так как она не только развивает колоссальное понимание строк в ЯП C, но и позволяет применить ранее изученные навыки(в частности машину тьюринга и диаграммер тьюринга).

